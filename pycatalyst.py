import os
import argparse
from modules import pytranslator # Assumes 'modules' directory is in the same dir or Python path

def convert(script_path, output_dir):
    """
    The entry point of the translator. 
    
    Parameters
    -----------
    script_path: str
        The path to the Python script to convert.
    output_dir: str
        The path to the directory to output the C++ file.
    """
    
    # Ensure the output directory exists
    if not os.path.exists(output_dir):
        try:
            os.makedirs(output_dir)
            print(f"Created output directory: {output_dir}")
        except OSError as e:
            print(f"Error: Could not create output directory {output_dir}. {e}")
            # It might be better to raise an exception or exit here
            # For now, PyTranslator will try to write and might fail if dir creation failed silently.
            # Added exit(1) in the main block for robustness.
            return # Or raise an error

    elif not os.path.isdir(output_dir):
        print(f"Error: Output path {output_dir} exists but is not a directory.")
        return # Or raise an error

    # Initialize the translator with the provided paths
    # These paths are now expected to be absolute or relative to the current working directory
    translator = pytranslator.PyTranslator(script_path, output_dir)
    
    # Run the translation process
    # This method internally calls write_cpp_files() which saves the output
    # and prints a confirmation message.
    translator.run()

    # Display the generated C++ code in the console
    if translator.output_files:
        print("\n--- Transpiled C++ Code ---")
        # Assuming the first file in output_files is the primary generated C++ file (e.g., main.cpp)
        # Each item in translator.output_files should be a CPPFile object
        if hasattr(translator.output_files[0], 'get_formatted_file_text'):
            cpp_code = translator.output_files[0].get_formatted_file_text()
            print(cpp_code)
        else:
            print("Error: Could not retrieve formatted C++ code from translator.")
        print("--- End of C++ Code ---\n")
    else:
        print("No C++ files were generated by the translator.")
    
if __name__ == "__main__":
    # Set up command-line argument parsing
    parser = argparse.ArgumentParser(
        description="Transpile a Python script to C++ using PyCatalyst. The C++ code will be displayed and saved."
    )
    parser.add_argument(
        "input_file", 
        help="Path to the Python script to be transpiled."
    )
    parser.add_argument(
        "output_dir", 
        help="Directory where the generated C++ file (e.g., main.cpp) will be saved."
    )

    # Parse the arguments provided by the user
    args = parser.parse_args()

    # Preliminary check for output directory (also done in convert, but good for early exit)
    if os.path.exists(args.output_dir) and not os.path.isdir(args.output_dir):
        print(f"Error: Output path '{args.output_dir}' exists but is not a directory.")
        exit(1)
    
    if not os.path.exists(args.output_dir):
        try:
            os.makedirs(args.output_dir)
            print(f"Created output directory: {args.output_dir}")
        except OSError as e:
            print(f"Error: Could not create output directory '{args.output_dir}'. {e}")
            exit(1)

    # Call the convert function with the parsed arguments
    convert(args.input_file, args.output_dir)
